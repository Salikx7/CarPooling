package mapsApi

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"

	"github.com/achintya-7/car_pooling_backend/utils"
)

type PredictionList struct {
	Predictions []struct {
		Description string `json:"description"`
		PlaceID     string `json:"place_id"`
	} `json:"predictions"`
}

type Predictions struct {
	Description string `json:"description"`
	PlaceId     string `json:"place_id"`
}

type Response struct {
	Result struct {
		Geometry struct {
			Location struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"location"`
		} `json:"geometry"`
	} `json:"result"`
}

type AutoGenerated struct {
	HTMLAttributions []interface{} `json:"html_attributions"`
	Result           struct {
		AddressComponents []struct {
			LongName  string   `json:"long_name"`
			ShortName string   `json:"short_name"`
			Types     []string `json:"types"`
		} `json:"address_components"`
		AdrAddress          string `json:"adr_address"`
		BusinessStatus      string `json:"business_status"`
		CurrentOpeningHours struct {
			OpenNow bool `json:"open_now"`
			Periods []struct {
				Close struct {
					Date      string `json:"date"`
					Day       int    `json:"day"`
					Time      string `json:"time"`
					Truncated bool   `json:"truncated"`
				} `json:"close"`
				Open struct {
					Date      string `json:"date"`
					Day       int    `json:"day"`
					Time      string `json:"time"`
					Truncated bool   `json:"truncated"`
				} `json:"open"`
			} `json:"periods"`
			WeekdayText []string `json:"weekday_text"`
		} `json:"current_opening_hours"`
		FormattedAddress string `json:"formatted_address"`
		Geometry         struct {
			Location struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"location"`
			Viewport struct {
				Northeast struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"northeast"`
				Southwest struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"southwest"`
			} `json:"viewport"`
		} `json:"geometry"`
		Icon                string `json:"icon"`
		IconBackgroundColor string `json:"icon_background_color"`
		IconMaskBaseURI     string `json:"icon_mask_base_uri"`
		Name                string `json:"name"`
		OpeningHours        struct {
			OpenNow bool `json:"open_now"`
			Periods []struct {
				Open struct {
					Day  int    `json:"day"`
					Time string `json:"time"`
				} `json:"open"`
			} `json:"periods"`
			WeekdayText []string `json:"weekday_text"`
		} `json:"opening_hours"`
		Photos []struct {
			Height           int      `json:"height"`
			HTMLAttributions []string `json:"html_attributions"`
			PhotoReference   string   `json:"photo_reference"`
			Width            int      `json:"width"`
		} `json:"photos"`
		PlaceID  string `json:"place_id"`
		PlusCode struct {
			CompoundCode string `json:"compound_code"`
			GlobalCode   string `json:"global_code"`
		} `json:"plus_code"`
		Rating    float64 `json:"rating"`
		Reference string  `json:"reference"`
		Reviews   []struct {
			AuthorName              string `json:"author_name"`
			AuthorURL               string `json:"author_url"`
			Language                string `json:"language"`
			OriginalLanguage        string `json:"original_language"`
			ProfilePhotoURL         string `json:"profile_photo_url"`
			Rating                  int    `json:"rating"`
			RelativeTimeDescription string `json:"relative_time_description"`
			Text                    string `json:"text"`
			Time                    int    `json:"time"`
			Translated              bool   `json:"translated"`
		} `json:"reviews"`
		Types                        []string `json:"types"`
		URL                          string   `json:"url"`
		UserRatingsTotal             int      `json:"user_ratings_total"`
		UtcOffset                    int      `json:"utc_offset"`
		Vicinity                     string   `json:"vicinity"`
		WheelchairAccessibleEntrance bool     `json:"wheelchair_accessible_entrance"`
	} `json:"result"`
	Status string `json:"status"`
}

type Location struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type Place struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type PolyPoints struct {
	Routes []struct {
		Bounds struct {
			Northeast struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"northeast"`
			Southwest struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"southwest"`
		} `json:"bounds"`
		Legs []struct {
			Steps []struct {
				StartLocation struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"start_location"`
			} `json:"steps"`
		} `json:"legs"`
	} `json:"routes"`
}

type Point struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type Bounds struct {
	LatNE float64 `json:"latNE"`
	LngNE float64 `json:"lngNE"`
	LatSW float64 `json:"latSW"`
	LngSW float64 `json:"lngSW"`
}

type Route struct {
	Points []Point `json:"points"`
	Bounds Bounds  `json:"bounds"`
}

type Cords struct {
	Results []struct {
		Geometry struct {
			Bounds struct {
				Northeast struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"northeast"`
				Southwest struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"southwest"`
			} `json:"bounds"`
			Location struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"location"`
		} `json:"geometry"`
	} `json:"results"`
}

func GetPlacePredictions(input string, config utils.Config) ([]Predictions, error) {
	location := "Northern India"

	apiUrl := fmt.Sprintf("https://maps.googleapis.com/maps/api/place/autocomplete/json?input=%s&location=%s&maxresults=6&key=%s", url.QueryEscape(input), url.QueryEscape(location), config.MapsKey)

	resp, err := http.Get(apiUrl)
	if err != nil {
		return nil, fmt.Errorf("cannot get place recommendations : %v", err)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("cannot read response body : %v", err)
	}

	var predictions []Predictions

	var predictionList PredictionList
	err = json.Unmarshal(body, &predictionList)
	if err != nil {
		print("cannot unmarshal response body : %v", err)
	}

	for _, prediction := range predictionList.Predictions {
		predictions = append(predictions, Predictions{
			Description: prediction.Description,
			PlaceId:     prediction.PlaceID,
		})
	}

	return predictions, nil

}

// * Not using now, Error in struct as well
func GetPlaceDetails(placeId string, config utils.Config) (Place, error) {
	apiUrl := fmt.Sprintf("https://maps.googleapis.com/maps/api/place/details/json?placeid=%s&key=%s", url.QueryEscape(placeId), config.MapsKey)

	resp, err := http.Get(apiUrl)
	if err != nil {
		return Place{}, fmt.Errorf("cannot get place details : %v", err)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return Place{}, fmt.Errorf("cannot read response body : %v", err)
	}

	fmt.Println(body)

	var placeDetail AutoGenerated
	err = json.Unmarshal(body, &placeDetail)
	if err != nil {
		return Place{}, fmt.Errorf("cannot unmarshal response body : %v", err)
	} else {
		fmt.Println(placeDetail)
	}

	place := Place{
		Lat: placeDetail.Result.Geometry.Location.Lat,
		Lng: placeDetail.Result.Geometry.Location.Lng,
	}

	return place, nil
}

func GetRoute(origin, destination string, config utils.Config) (Route, error) {
	var route Route

	apiUrl := fmt.Sprintf("https://maps.googleapis.com/maps/api/directions/json?origin=%s&destination=%s&key=%s", url.QueryEscape(origin), url.QueryEscape(destination), config.MapsKey)

	resp, err := http.Get(apiUrl)
	if err != nil {
		return route, fmt.Errorf("cannot get route : %v", err)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return route, fmt.Errorf("cannot read response body : %v", err)
	}

	var polyPoints PolyPoints
	err = json.Unmarshal(body, &polyPoints)
	if err != nil {
		return route, fmt.Errorf("cannot unmarshal response body : %v", err)
	}

	route.Bounds = Bounds{
		LatNE: polyPoints.Routes[0].Bounds.Northeast.Lat,
		LngNE: polyPoints.Routes[0].Bounds.Northeast.Lng,
		LatSW: polyPoints.Routes[0].Bounds.Southwest.Lat,
		LngSW: polyPoints.Routes[0].Bounds.Southwest.Lng,
	}

	for _, step := range polyPoints.Routes[0].Legs[0].Steps {
		route.Points = append(route.Points, Point{
			Lat: step.StartLocation.Lat,
			Lng: step.StartLocation.Lng,
		})
	}

	return route, nil
}

func GetCords(placeId string, config utils.Config) (Point, error) {
	var point Point

	apiUrl := fmt.Sprintf("https://maps.googleapis.com/maps/api/geocode/json?place_id=%s&key=%s", url.QueryEscape(placeId), config.MapsKey)

	resp, err := http.Get(apiUrl)
	if err != nil {
		return point, fmt.Errorf("cannot get route : %v", err)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return point, fmt.Errorf("cannot read response body : %v", err)
	}

	var cords Cords
	err = json.Unmarshal(body, &cords)
	if err != nil {
		return point, fmt.Errorf("cannot unmarshal response body : %v", err)
	}

	point = Point{
		Lat: cords.Results[0].Geometry.Location.Lat,
		Lng: cords.Results[0].Geometry.Location.Lng,
	}

	return point, nil
}
